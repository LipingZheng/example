{
  "name": "Example",
  "tagline": "",
  "body": "#Judgment Aggregation Rules\r\nThis webpage is about the instances, the experiment results, the generator and the solver for the problem of computing majority-preserving judgment aggreagtion rules.\r\nJudgment aggregtion is the problem of finding a collective judgment set on a given profile of individual judgment sets. And what we focus on is the winner determination problem of the majority judgment aggregation rules, and we provide the solver for the problem.\r\n\r\nWe provide a generator for producing the random judgment aggregation instances both complete and incomplete and the solver for computing majority-preserving judgment aggregation rules. The instances we provide are those we use to do our experiment. In our experiment, we use incomplete instances to compute the MSA rule to find out how this rule performs with the instances with different arguments. Notice that you can also use complete instances to do this experiment. And then we provide complete instances for testing the computing time of five majority-preserving judgment aggregation rules, since the MNAC rule need the complete instances.\r\n\r\nMore details about the problem of judgment aggregation and the experiment can be found in some related papers. \r\n### Designer Templates\r\nWeâ€™ve crafted some handsome templates for you to use. Go ahead and click 'Continue to layouts' to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved.\r\n\r\n### JAGen\r\nWe provide a generator JAGen for generating random judgment aggregation examples. Use JAGen, we can generate different instances by the arguments we set. The related command options of JAGen are as followings:\r\n\r\n    -h : display usage instructions\r\n    -c : to generate only complete judgment sets\r\n    -p : the size of preagenda [default:5]\r\n    -a : the total number of atoms [default:6]\r\n    -o : the max number of operators [default:5]\r\n    -j : the number of judgment sets [default:10]\r\n    -conj :the provability of conjunctions [default:0.33]\r\n    -disj :the provability of disjunctions [default:0.33] \r\n\r\nThe command about calling JAGen is like this:\r\n\r\n    jagen <filename> [options] \r\n\r\nThe filename is the name of the instance that we want to generate and is required. The options can be set as you need. If do you not entered the option, JAGen will use the default setting.\r\n\r\nThe instance we provide contains a preagenda and a profile and just like this: rMJA_5atom_4op_6p_001. In this instance, it uses at most 5 atoms and 4 operators to construct formulas in the preagenda. And the size of the preagenda is 6. And the formulas in the preagenda is constructed randomly, so do the consistent judgment sets in the profile. In rMJA_5atom_4op_6p_001, we first list the formulas in the preagenda. The formulas are just like these\r\n\r\n    ((p5 | p3) | ((p4 | p1) | p2))\r\n    (~p1 | (~p2 | p5))\r\n    ~(p1 & (p4 | p3))\r\n    (p3 | p2)\r\n    ~p3\r\n    ~(p3 | ~p4) \r\n\r\nWe use operators in { ~, &, |} to construct the formula, and the provablility about the operators are set up by the command options \"-conj\" and \"-disj\". Note that ~, & and | means negation, and and or as in proposition logic. The list ends by #.\r\n\r\nThen we list the judgment sets like\r\n\r\n    1 1 1 0 1 *\r\n\r\n1 means that the judgment of the formula in the preagenda is true, 0 means false, i.e. to choose the corresponding negative one in the judgment set and * means unknow. This is an incomplete judgment aggregation example since we do not entered the option \"-c\". Notice that the complete one does not contains * in the judgment sets. And the number of the judgment sets is set by the option \"-j\". This list also ends by #.\r\n\r\n\r\n### JASolver\r\nWe use JASolver as the solver for computing majority-preserving judgment aggregation rules that we defined in [1].\r\nJASolver consists of two main part, one is the program ja , and the other is a default slover called dl2asp. ja does preliminary work for dl2asp. And we provide a shell called JASolver.sh as the solver entry. In JASolver.sh, we first call ja to do some translation work and then use dl2asp to compute the rule we choose. At last we deal with the output file of dl2asp to generate the computing result of the instance.\r\nThe related command options of JASolver.sh are as followings :\r\n\r\n    -f <filename> : input file\r\n    -r <rule> : for choosing calculate rule (msa, mcsa, ra, mwa, mnac)\r\n    -a : to output all winners\r\n    -d : to only output the default theory\r\n    -i <formula> : to test whether the given formula is in all winners \r\n\r\nThe command about calling JASolver is as following:\r\n\r\n    JASolver.sh -f <filename> -r <rule> [ -a -d ] [ -i <formula> ] \r\n\r\nTo use JASolver, filename and rule are required, and other options are optional.And it should pay attentions to the content of the computing file, which must be strictly ordered like the instances we provide, otherwise there will exists some parse errors.\r\n\r\nThe program ja translates the rule that we choose according to the propositions we define in the paper. And the default theory solver dl2asp translates default theory to the corresponding answer set program. And we implement a new version of dl2asp in order to compute optimal extensions. \r\n\r\n### Download\r\nJAGen:\r\n\r\nJASolver:\r\n\r\nInstances:\r\n\r\nExperiment Result:",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}